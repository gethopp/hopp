use std::{
    sync::{mpsc::Sender, Arc, Mutex},
    time::{Duration, Instant},
};

use crate::{
    graphics::graphics_context::{participant::cursor::CursorMode, RedrawThreadCommands},
    overlay_window::OverlayWindow,
    utils::{clock::Clock, geometry::Position},
    MouseClickData, ScrollDelta, UserEvent,
};

use log::{debug, error};
use winit::event_loop::EventLoopProxy;

/// Platform-specific mouse input implementations and cursor control system.
///
/// This module provides a comprehensive cursor management system that handles both local
/// and remote mouse input, visual cursor representation, and control switching between
/// multiple users. The core component is `CursorController` which coordinates between
/// platform-specific mouse capture and simulation.
///
/// # Core Components
///
/// * **CursorController**: Main API for cursor management and control switching
/// * **MouseObserver**: Platform-specific mouse event capture (background service)
/// * **CursorSimulator**: Platform-specific mouse event injection
///
/// # Control Flow
///
/// The system manages control states between a local sharer and multiple remote controllers:
///
/// * **Sharer Control**: Local user has control, system cursor moves normally, controller cursors are visible
/// * **Controller Control**: A remote controller has control, system cursor follows remote input, sharer virtual cursor is visible
///
/// Control automatically switches based on input activity:
/// * Clicks or scrolling gives control to either the sharer or one controller
/// * Only one entity (sharer or one controller) can have control at a time
///
/// # Multi-Controller Support
///
/// The system supports multiple simultaneous remote controllers, each identified by a unique SID:
/// * Each controller has its own visual cursor representation
/// * Controllers can be individually enabled/disabled for input processing
/// * Controller visibility can be individually controlled (full cursor vs pointer icon)
/// * Control can transfer between any controller or back to the sharer
///
/// # Platform Abstraction
///
/// Each platform implements `MouseObserver` for event capture and `CursorSimulator`
/// for event injection, providing consistent behavior across operating systems.
#[cfg(target_os = "macos")]
#[path = "mouse_macos.rs"]
mod platform;

#[cfg(target_os = "windows")]
#[path = "mouse_windows.rs"]
mod platform;

#[cfg(target_os = "linux")]
#[path = "mouse_linux.rs"]
mod platform;

pub use platform::{CursorSimulator, MouseObserver};

/// Custom identifier used to mark simulated mouse events to prevent feedback loops.
///
/// This constant is embedded in platform-specific mouse events generated by the
/// cursor simulator to distinguish them from real user input. When the mouse
/// observer captures events, it checks for this identifier and ignores events
/// that originated from the simulator itself.
///
/// # Platform Usage
///
/// * **macOS**: Set in `EVENT_SOURCE_USER_DATA` field of CGEvent
/// * **Windows**: Set in `dwExtraInfo` field of MOUSEINPUT structure
/// * **Default**: Not used (no event simulation)
///
/// # Purpose
///
/// Prevents infinite feedback loops where:
/// 1. Simulator generates mouse event with this ID
/// 2. Observer captures the event but sees the ID
/// 3. Observer ignores the event (no feedback to remote)
/// 4. Loop is broken, preventing recursive event generation
pub const CUSTOM_MOUSE_EVENT: i64 = 1234;

const CURSOR_HIDE_TIMEOUT: Duration = Duration::from_secs(5);

const SHARER_POSITION_UPDATE_INTERVAL: Duration = Duration::from_millis(30);

/// Specific error types for CursorController initialization failures.
///
/// These errors provide detailed information about what component failed during
/// CursorController creation, enabling better error handling and debugging.
#[derive(Debug, thiserror::Error)]
pub enum CursorControllerError {
    /// Failed to initialize platform-specific mouse event capture.
    ///
    /// This indicates the underlying platform API failed to initialize.
    /// Common causes include missing permissions or insufficient privileges.
    #[error("Failed to create mouse observer")]
    MouseObserverCreationFailed,
}

/// Platform-agnostic trait for mouse event simulation.
///
/// This trait defines the interface that all platform-specific cursor simulators
/// must implement. It provides methods for simulating mouse movements, clicks,
/// and scroll events at the operating system level.
///
/// ## Platform Implementation Notes:
/// - **macOS**: Uses CGEvent API with Core Graphics event sources
/// - **Windows**: Uses SendInput API with virtual desktop coordinates
/// - **Default**: No-op implementation that logs errors
///
/// All implementations should:
/// 1. Mark simulated events to prevent feedback loops
/// 2. Handle coordinate system differences appropriately
/// 3. Preserve modifier keys and click counts
/// 4. Provide reasonable scroll wheel scaling
pub trait CursorSimulatorFunctions {
    /// Simulates cursor movement to the specified position.
    ///
    /// # Parameters
    /// - `position`: Absolute screen coordinates for cursor placement
    /// - `click_down`: Whether this is a drag operation (mouse button held)
    ///
    /// # Platform Behavior:
    /// - **macOS**: Direct CGEvent posting with pixel coordinates
    /// - **Windows**: SendInput with virtual desktop coordinate mapping
    /// - **Default**: Logs error message only
    fn simulate_cursor_movement(&mut self, position: Position, click_down: bool);

    /// Simulates a mouse click event.
    ///
    /// # Parameters
    /// - `click_data`: Contains button, position, modifiers, and click count
    ///
    /// # Platform Behavior:
    /// - **macOS**: Preserves modifier flags and click count natively
    /// - **Windows**: Converts to INPUT structure with virtual coordinates
    /// - **Default**: Logs error message only
    fn simulate_click(&mut self, click_data: MouseClickData);

    /// Simulates mouse scroll wheel events.
    ///
    /// # Parameters
    /// - `delta`: Scroll delta with x (horizontal) and y (vertical) components
    ///
    /// # Platform Behavior:
    /// - **macOS**: Direct pixel-based scrolling via CGEvent
    /// - **Windows**: Complex translation to WHEEL_DELTA units with rate limiting
    /// - **Default**: Logs error message only
    fn simulate_scroll(&mut self, delta: ScrollDelta);
}

struct CursorState {
    /// Cursor's position in global coordinates, this is used when simulating events
    global_position: Position,
    /// Cursor's position in local coordinates, this is used for rendering
    local_position: Position,
    /// Timestamp of the last time the cursor was shown, used for auto-hiding
    last_show_time: Option<Instant>,
    /// Whether the cursor is currently visible
    visible: bool,
    redraw_thread_sender: Sender<RedrawThreadCommands>,
    /// Clock for time tracking
    clock: Arc<dyn Clock>,
}

impl CursorState {
    fn new(redraw_thread_sender: Sender<RedrawThreadCommands>, clock: Arc<dyn Clock>) -> Self {
        Self {
            global_position: Position::default(),
            local_position: Position::default(),
            last_show_time: None,
            visible: false,
            redraw_thread_sender,
            clock,
        }
    }

    fn set_position(&mut self, global_position: Position, local_position: Position, show: bool) {
        log::debug!(
            "set_position: global_position: {global_position:?} local_position: {local_position:?}"
        );
        self.global_position = global_position;
        self.local_position = local_position;
        if show {
            self.last_show_time = Some(self.clock.now());
            self.visible = true;
            if let Err(e) = self
                .redraw_thread_sender
                .send(RedrawThreadCommands::Activity)
            {
                log::error!("set_position: error sending redraw event: {e:?}");
            }
        }
    }

    fn hide(&mut self) {
        self.last_show_time = None;
        self.visible = false;
        if let Err(e) = self
            .redraw_thread_sender
            .send(RedrawThreadCommands::Activity)
        {
            log::error!("hide: error sending redraw event: {e:?}");
        }
    }

    fn show(&mut self) {
        self.last_show_time = Some(self.clock.now());
        self.visible = true;
        if let Err(e) = self
            .redraw_thread_sender
            .send(RedrawThreadCommands::Activity)
        {
            log::error!("show: error sending redraw event: {e:?}");
        }
    }

    fn hide_if_expired(&mut self) {
        if let Some(last_show) = self.last_show_time {
            if self.clock.now().duration_since(last_show) > CURSOR_HIDE_TIMEOUT {
                self.hide();
            }
        }
    }
}

struct ControllerCursor {
    /// Cursor state
    cursor_state: CursorState,
    /*
     * This is used to record when the controller
     * clicked down. Then for each mouse move we
     * send LeftMouseDragged instead of MouseMoved.
     */
    clicked: bool,
    mode: CursorMode,
    pointer_mode: bool,
    has_control: bool,
    sid: String,
}

impl ControllerCursor {
    fn new(cursor_state: CursorState, sid: String, mode: CursorMode) -> Self {
        Self {
            cursor_state,
            clicked: false,
            mode,
            pointer_mode: mode == CursorMode::Pointer,
            has_control: false,
            sid,
        }
    }

    fn set_position(&mut self, global_position: Position, local_position: Position) {
        log::debug!(
            "controller_cursor: set_position: global_position: {:?} local_position: {:?} has_control: {} mode: {:?}",
            global_position,
            local_position,
            self.has_control,
            self.mode
        );
        self.cursor_state
            .set_position(global_position, local_position, !self.has_control);
    }

    fn show(&mut self) {
        self.has_control = false;
        self.cursor_state.show();
    }

    fn hide(&mut self) {
        self.has_control = true;
        self.cursor_state.hide();
    }

    fn mode(&self) -> CursorMode {
        self.mode
    }

    fn set_mode(&mut self, mode: CursorMode) {
        self.mode = mode;
    }

    fn set_pointer_mode(&mut self, enabled: bool, remote_control_enabled: bool) {
        if !enabled && remote_control_enabled {
            self.mode = CursorMode::Normal;
        } else {
            self.mode = CursorMode::Pointer;
        }
        self.pointer_mode = enabled;
    }

    fn pointer_mode(&self) -> bool {
        self.pointer_mode
    }

    fn clicked(&mut self) -> bool {
        self.clicked
    }

    fn set_clicked(&mut self, clicked: bool) {
        self.clicked = clicked;
    }

    fn global_position(&self) -> Position {
        self.cursor_state.global_position
    }

    fn local_position(&self) -> Position {
        self.cursor_state.local_position
    }

    fn visible(&self) -> bool {
        self.cursor_state.visible
    }

    fn has_control(&self) -> bool {
        self.has_control
    }

    fn hide_if_expired(&mut self) {
        self.cursor_state.hide_if_expired();
    }
}

fn is_out_of_bounds(position: Position) -> bool {
    if !(0.0..=1.0).contains(&position.x) {
        return true;
    }
    if !(0.0..=1.0).contains(&position.y) {
        return true;
    }
    false
}

pub struct SharerCursor {
    cursor_state: CursorState,
    has_control: bool,
    event_loop_proxy: EventLoopProxy<UserEvent>,
    overlay_window: Arc<OverlayWindow>,
    /// We are using this to take control back when the sharer clicks/scrolls
    controllers_cursors: Arc<Mutex<Vec<ControllerCursor>>>,
    cursor_simulator: Arc<Mutex<CursorSimulator>>,
    last_event_position: Position,
    last_event_position_time: Instant,
}

impl SharerCursor {
    fn new(
        cursor_state: CursorState,
        event_loop_proxy: EventLoopProxy<UserEvent>,
        overlay_window: Arc<OverlayWindow>,
        cursor_simulator: Arc<Mutex<CursorSimulator>>,
        controllers_cursors: Arc<Mutex<Vec<ControllerCursor>>>,
    ) -> Self {
        Self {
            cursor_state,
            has_control: true,
            event_loop_proxy,
            overlay_window,
            controllers_cursors,
            cursor_simulator,
            last_event_position: Position::default(),
            last_event_position_time: Instant::now(),
        }
    }

    // The result is whether or not the sharer left the monitor.
    fn set_position(&mut self, global_position: Position) -> bool {
        log::debug!("sharer_cursor: set_position: global_position: {global_position:?}");

        let local_position = self
            .overlay_window
            .local_percentage_from_global(global_position.x, global_position.y);
        let display_percentage = self
            .overlay_window
            .global_percentage_from_global(global_position.x, global_position.y);

        self.cursor_state
            .set_position(global_position, local_position, !self.has_control);

        // This needs to be after we have set the position in order to use the correct global position
        // when hiding the virtual cursor.
        let mut left_monitor = false;
        if is_out_of_bounds(local_position) && !self.has_control {
            log::info!("sharer_cursor: set_position: sharer left monitor");
            self.hide(true);
            left_monitor = true;
        }

        if self.last_event_position_time.elapsed() > SHARER_POSITION_UPDATE_INTERVAL {
            let res = self.event_loop_proxy.send_event(UserEvent::SharerPosition(
                display_percentage.x,
                display_percentage.y,
            ));
            if let Err(e) = res {
                error!("sharer_cursor: set_position: error sending sharer position: {e:?}");
            }
            self.last_event_position_time = Instant::now();
        }

        left_monitor
    }

    fn click(&mut self) {
        log::debug!("sharer_cursor: click: has_control: {}", self.has_control);

        if self.has_control {
            return;
        }

        self.hide(true);

        /*
         * When the sharer takes back control with with a click, we need to move
         * the system cursor to the position of the click, because the system cursor
         * was were the controlling controller was.
         */
        let mut cursor_simulator = self.cursor_simulator.lock().unwrap();
        let global_position = self.global_position();
        cursor_simulator.simulate_click(MouseClickData {
            x: global_position.x as f32,
            y: global_position.y as f32,
            button: 0,
            clicks: 1.,
            down: true,
            shift: false,
            alt: false,
            ctrl: false,
            meta: false,
        });
    }

    fn scroll(&mut self) {
        log::debug!("sharer_cursor: scroll: has_control: {}", self.has_control);

        if self.has_control {
            return;
        }

        self.hide(true);
    }

    fn has_control(&self) -> bool {
        self.has_control
    }

    fn global_position(&self) -> Position {
        self.cursor_state.global_position
    }

    fn local_position(&self) -> Position {
        self.cursor_state.local_position
    }

    fn visible(&self) -> bool {
        self.cursor_state.visible
    }

    fn show(&mut self) {
        self.has_control = false;
        self.cursor_state.show();
    }

    // show_controller needs to be false when this is called from another object.
    fn hide(&mut self, show_controller: bool) {
        self.has_control = true;
        self.cursor_state.hide();

        {
            let mut cursor_simulator = self.cursor_simulator.lock().unwrap();
            let global_position = self.global_position();
            cursor_simulator.simulate_cursor_movement(global_position, false);
        }

        let res = self
            .event_loop_proxy
            .send_event(UserEvent::ParticipantInControl("sharer".to_string()));
        if let Err(e) = res {
            error!("sharer_cursor: click: error sending participant in control: {e:?}");
        }

        if show_controller {
            let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
            for controller in controllers_cursors.iter_mut() {
                if controller.has_control() {
                    controller.show();
                }
            }
        }
    }

    #[allow(dead_code)]
    fn set_last_event_position(&mut self, position: Position) {
        self.last_event_position = position;
    }

    #[allow(dead_code)]
    fn get_last_event_position(&self) -> Position {
        self.last_event_position
    }
}

struct RemoteControl {
    /// Cursor that is shown when the sharer looses control
    sharer_cursor: Arc<Mutex<SharerCursor>>,
    /// Object that is used to simulate mouse events
    cursor_simulator: Arc<Mutex<CursorSimulator>>,
    /// Platform-specific mouse event observer.
    ///
    /// Captures system-wide mouse events and updates internal state via callbacks.
    /// Lifetime parameter ensures observer doesn't outlive controller.
    _mouse_observer: MouseObserver,
}

/// Main cursor controller that manages both local and remote cursor interactions.
///
/// It manages the visual representation of multiple remote controller cursors and
/// handles control switching between the local sharer and remote controllers.
///
/// ## Architecture:
/// - **MouseObserver**: Platform-specific event capture
/// - **CursorSimulator**: Platform-specific event injection
/// - **Multi-Controller Support**: Manages up to MAX_CURSORS simultaneous controllers
///
/// ## Controller Management:
/// - Controllers are identified by unique session IDs (SIDs)
/// - Each controller has independent enable/disable and visibility states
/// - Controllers can be dynamically added and removed during sessions
/// - Visual cursor representation includes user badges with distinct colors
///
/// ## Error Handling:
/// Constructor returns `CursorControllerError` with specific failure reasons:
/// - `MouseObserverCreationFailed`: Platform mouse capture initialization failed
pub struct CursorController {
    /// Objects that are used for remote control. When accessibility permission is not granted,
    /// this is None.
    remote_control: Option<RemoteControl>,
    /// Cursors for the remote controllers
    controllers_cursors: Arc<Mutex<Vec<ControllerCursor>>>,
    /// Controllers' cursors enabled by the shared
    controllers_cursors_enabled: bool,
    /// Object that is used to translate coordinates between local and global
    overlay_window: Arc<OverlayWindow>,
    /// Sender for the redraw thread
    redraw_thread_sender: Sender<RedrawThreadCommands>,
    /// Event loop proxy for sending events
    event_loop_proxy: EventLoopProxy<UserEvent>,
    /// Clock for time tracking
    clock: Arc<dyn Clock>,
}

impl CursorController {
    /// Creates a new cursor controller with platform-specific mouse capture and simulation.
    ///
    /// This function initializes all necessary components for cursor management:
    /// - Sets up platform-specific mouse event capture
    /// - Initializes cursor simulation capabilities
    /// - Establishes communication with the overlay systems
    /// - Prepares infrastructure for managing multiple remote controllers
    ///
    /// Note: Remote controllers are added separately using `add_controller()` method.
    ///
    /// # Parameters
    ///
    /// * `overlay_window` - Shared overlay window for coordinate transformations
    /// * `redraw_thread_sender` - Sender for triggering redraws
    /// * `event_loop_proxy` - Event loop proxy for sending cursor position updates
    /// * `accessibility_permission` - Whether accessibility permissions are granted
    /// * `clock` - Clock for time tracking
    ///
    /// # Returns
    ///
    /// * `Ok(CursorController)` - Successfully initialized controller
    /// * `Err(CursorControllerError)` - Specific failure reason (see error variants)
    pub(crate) fn new(
        overlay_window: Arc<OverlayWindow>,
        redraw_thread_sender: Sender<RedrawThreadCommands>,
        event_loop_proxy: EventLoopProxy<UserEvent>,
        accessibility_permission: bool,
        clock: Arc<dyn Clock>,
    ) -> Result<Self, CursorControllerError> {
        let controllers_cursors = Arc::new(Mutex::new(vec![]));
        let remote_control = if accessibility_permission {
            let cursor_simulator = Arc::new(Mutex::new(CursorSimulator::new()));
            let sharer_cursor = Arc::new(Mutex::new(SharerCursor::new(
                CursorState::new(redraw_thread_sender.clone(), clock.clone()),
                event_loop_proxy.clone(),
                overlay_window.clone(),
                cursor_simulator.clone(),
                controllers_cursors.clone(),
            )));

            let mouse_observer = MouseObserver::new(sharer_cursor.clone());
            if mouse_observer.is_err() {
                error!("CursorController::new: error creating mouse observer");
                return Err(CursorControllerError::MouseObserverCreationFailed);
            }
            let mouse_observer = mouse_observer.unwrap();

            Some(RemoteControl {
                sharer_cursor,
                cursor_simulator,
                _mouse_observer: mouse_observer,
            })
        } else {
            None
        };

        Ok(Self {
            remote_control,
            controllers_cursors,
            controllers_cursors_enabled: accessibility_permission,
            overlay_window,
            redraw_thread_sender,
            event_loop_proxy,
            clock,
        })
    }

    /// Adds a new remote controller to the cursor management system.
    ///
    /// This function adds a controller to the active controller list for state tracking.
    ///
    /// # Parameters
    ///
    /// * `sid` - Unique session ID for the controller (must not already exist)
    ///
    /// # Returns
    ///
    /// * `Ok(())` - Controller successfully added
    pub fn add_controller(&mut self, sid: String) {
        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        log::info!(
            "add_controller: sid: {} controllers_cursors: {}",
            sid,
            controllers_cursors.len()
        );

        // Check if controller already exists
        for controller in controllers_cursors.iter() {
            if controller.sid == sid {
                log::warn!("add_controller: controller {} already exists", sid);
                return;
            }
        }

        let mode = if self.controllers_cursors_enabled {
            CursorMode::Normal
        } else {
            CursorMode::Pointer
        };
        controllers_cursors.push(ControllerCursor::new(
            CursorState::new(self.redraw_thread_sender.clone(), self.clock.clone()),
            sid,
            mode,
        ));
    }

    /// Removes a remote controller from the cursor management system.
    ///
    /// This function removes the specified controller from the active controller list
    /// and cleans up its visual resources. If the removed controller currently has
    /// control, control will remain with the system until another input event occurs.
    ///
    /// # Parameters
    ///
    /// * `sid` - Session ID of the controller to remove
    ///
    /// # Behavior
    ///
    /// * If the controller exists, it is immediately removed from the list
    /// * If the controller doesn't exist, the operation is silently ignored
    /// * Visual cursor resources are automatically cleaned up
    /// * Control state is preserved until next input event
    pub fn remove_controller(&mut self, sid: &str) {
        log::info!("remove_controller: {sid}");
        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();

        if let Some(pos) = controllers_cursors
            .iter()
            .position(|controller| controller.sid == sid)
        {
            controllers_cursors.remove(pos);
            if let Err(e) = self
                .redraw_thread_sender
                .send(RedrawThreadCommands::Activity)
            {
                log::error!("remove_controller: error sending redraw event: {e:?}");
            }
        } else {
            // no-op if not present
            log::info!("remove_controller: controller with sid {} not found", sid);
        }
    }

    /// Handles controller cursor movement from remote input.
    ///
    /// This function processes cursor movement commands from a specific remote controller,
    /// updating both the visual cursor position and potentially moving the system
    /// cursor if that controller has control.
    ///
    /// # Parameters
    ///
    /// * `x` - Local window coordinates as percentage (0.0-1.0 range) for horizontal position
    /// * `y` - Local window coordinates as percentage (0.0-1.0 range) for vertical position
    /// * `sid` - Session ID identifying which controller is moving
    pub fn cursor_move_controller(&mut self, x: f64, y: f64, sid: &str) {
        debug!("cursor_move_controller: x: {x} y: {y}");

        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter_mut() {
            if controller.sid != sid {
                continue;
            }

            let local_position = self.overlay_window.translate_location(x, y);
            let global_position = self.overlay_window.translate_to_global(x, y);

            controller.set_position(global_position, local_position);
            if controller.has_control() && self.remote_control.is_some() {
                let mut cursor_simulator = self
                    .remote_control
                    .as_ref()
                    .unwrap()
                    .cursor_simulator
                    .lock()
                    .unwrap();
                cursor_simulator.simulate_cursor_movement(global_position, controller.clicked());
            }
            break;
        }
    }

    /// Handles mouse click events from a specific remote controller.
    ///
    /// This function processes mouse button press/release events from a specific remote controller,
    /// potentially taking control from the local sharer or other controllers and simulating
    /// the click on the local system.
    ///
    /// # Parameters
    ///
    /// * `click_data` - Complete mouse click information including:
    /// * `sid` - Session ID identifying which controller is clicking
    pub fn mouse_click_controller(&mut self, mut click_data: MouseClickData, sid: &str) {
        debug!("mouse_click_controller: {click_data:?}");
        if self.remote_control.is_none() {
            log::warn!("mouse_click_controller: remote control is none");
            return;
        }

        let mut control_changed = false;
        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter_mut() {
            if controller.sid != sid {
                continue;
            }

            if controller.mode() != CursorMode::Normal {
                log::info!("mouse_click_controller: controller mode is not Normal.");
                break;
            }

            let global_position = self
                .overlay_window
                .translate_to_global(click_data.x as f64, click_data.y as f64);
            click_data.x = global_position.x as f32;
            click_data.y = global_position.y as f32;

            /* Take control. */
            if click_data.down && !controller.has_control() {
                debug!("mouse_click_controller: controller {sid} takes control.");
                controller.hide();
                control_changed = true;
            }

            if click_data.clicks <= 1. {
                controller.set_clicked(click_data.down);
            }

            let mut cursor_simulator = self
                .remote_control
                .as_ref()
                .unwrap()
                .cursor_simulator
                .lock()
                .unwrap();
            /* Take the cursor to the controller's position. */
            cursor_simulator.simulate_cursor_movement(global_position, false);
            cursor_simulator.simulate_click(click_data);

            break;
        }

        /* Remove control from the previous controller. */
        if control_changed {
            for controller in controllers_cursors.iter_mut() {
                if controller.has_control() && controller.sid != sid {
                    controller.show();
                }
            }
        }

        /* Show the sharer cursor. */
        let mut sharer_cursor = self
            .remote_control
            .as_ref()
            .unwrap()
            .sharer_cursor
            .lock()
            .unwrap();
        if sharer_cursor.has_control() && control_changed {
            sharer_cursor.show();
        }

        /* Notify controllers who has control. */
        if control_changed {
            let res = self
                .event_loop_proxy
                .send_event(UserEvent::ParticipantInControl(sid.to_string()));
            if let Err(e) = res {
                error!("mouse_click_controller: error sending participant in control: {e:?}");
            }
        }
    }

    /// Handles scroll wheel events from a specific remote controller.
    ///
    /// This function processes scroll wheel input from a specific remote controller,
    /// potentially taking control from the local sharer or other controllers and
    /// simulating the scroll action on the local system.
    ///
    /// # Parameters
    ///
    /// * `delta` - Scroll wheel movement with:
    /// * `sid` - Session ID identifying which controller is scrolling
    pub fn scroll_controller(&mut self, delta: ScrollDelta, sid: &str) {
        debug!("scroll_controller: {delta:?}");

        if self.remote_control.is_none() {
            log::warn!("scroll_controller: remote control is none");
            return;
        }

        let mut control_changed = false;
        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter_mut() {
            if controller.sid != sid {
                continue;
            }

            if controller.mode() != CursorMode::Normal {
                log::info!("scroll_controller: controller mode is not Normal.");
                break;
            }

            if !controller.has_control() {
                control_changed = true;
                controller.hide();
            }

            let mut cursor_simulator = self
                .remote_control
                .as_ref()
                .unwrap()
                .cursor_simulator
                .lock()
                .unwrap();
            cursor_simulator.simulate_cursor_movement(controller.global_position(), false);
            cursor_simulator.simulate_scroll(delta);

            break;
        }

        /* Remove control from the previous controller. */
        if control_changed {
            for controller in controllers_cursors.iter_mut() {
                if controller.has_control() && controller.sid != sid {
                    controller.show();
                }
            }
        }

        /* Show the sharer cursor. */
        let mut sharer_cursor = self
            .remote_control
            .as_ref()
            .unwrap()
            .sharer_cursor
            .lock()
            .unwrap();
        if sharer_cursor.has_control() && control_changed {
            sharer_cursor.show();
        }

        /* Notify controllers who has control. */
        if control_changed {
            let res = self
                .event_loop_proxy
                .send_event(UserEvent::ParticipantInControl(sid.to_string()));
            if let Err(e) = res {
                error!("scroll_controller: error sending participant in control: {e:?}");
            }
        }
    }

    /// Enables or disables input processing for all controllers.
    ///
    /// This function controls whether remote controllers can interact with the
    /// local system. When enabled, cursors show in Normal mode. When disabled,
    /// cursors show in Pointer mode (interaction blocked).
    ///
    /// # Parameters
    ///
    /// * `enabled` - Whether to enable (true) or disable (false) input for all controllers
    pub fn set_controllers_enabled(&mut self, enabled: bool) {
        log::info!("set_controllers_enabled: {enabled}");
        if self.remote_control.is_none() {
            log::warn!("set_controllers_enabled: remote control is none");
            return;
        }

        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        self.controllers_cursors_enabled = enabled;

        for controller in controllers_cursors.iter_mut() {
            if enabled {
                if controller.pointer_mode() {
                    controller.set_mode(CursorMode::Pointer);
                } else {
                    controller.set_mode(CursorMode::Normal);
                }
            } else {
                controller.set_mode(CursorMode::Pointer);
            }

            if controller.has_control() {
                controller.show();
                let mut sharer_cursor = self
                    .remote_control
                    .as_ref()
                    .unwrap()
                    .sharer_cursor
                    .lock()
                    .unwrap();
                // We are setting show_controller to false because we have the controllers_cursors locked.
                // If we set it to true, it will deadlock.
                sharer_cursor.hide(false);
            }
        }
    }

    /// Switch pointer mode made by the controller.
    /// # Parameters
    ///
    /// * `sid` - Session ID identifying which controller to modify
    /// * `enabled` - Whether to enable (true) or disable (false) pointer mode for the specified controller
    pub fn set_controller_pointer(&mut self, enabled: bool, sid: &str) {
        log::info!("set_controller_pointer: {sid} {enabled}");

        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter_mut() {
            if controller.sid != sid {
                continue;
            }

            if controller.has_control() {
                log::info!("set_controller_pointer: controller {sid} has control, give control back to sharer.");
                controller.show();
                let mut sharer_cursor = self
                    .remote_control
                    .as_ref()
                    .unwrap()
                    .sharer_cursor
                    .lock()
                    .unwrap();
                // We are setting show_controller to false because we have the controllers_cursors locked.
                // If we set it to true, it will deadlock.
                sharer_cursor.hide(false);
            }

            controller.set_pointer_mode(enabled, self.controllers_cursors_enabled);
            break;
        }
    }

    /// Updates cursor positions in the ParticipantsManager for rendering.
    ///
    /// This function translates cursor state to pixel positions and updates the
    /// ParticipantsManager for iced-based rendering.
    ///
    /// # Parameters
    ///
    /// * `participants_manager` - Mutable reference to the ParticipantsManager
    ///
    pub fn update_cursors(
        &self,
        participants_manager: &mut crate::graphics::graphics_context::participant::ParticipantsManager,
    ) {
        // Update sharer cursor
        if let Some(remote_control) = &self.remote_control {
            let sharer_cursor = remote_control.sharer_cursor.lock().unwrap();
            if sharer_cursor.visible() {
                let local_pos = sharer_cursor.local_position();
                let pixel_pos = self
                    .overlay_window
                    .get_pixel_position(local_pos.x, local_pos.y);
                participants_manager.set_cursor_position("local", Some(pixel_pos));
            } else {
                participants_manager.set_cursor_position("local", None);
            }
        }

        // Update controller cursors
        let controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter() {
            if controller.visible() {
                let local_pos = controller.local_position();
                let pixel_pos = self
                    .overlay_window
                    .get_pixel_position(local_pos.x, local_pos.y);
                participants_manager.set_cursor_position(&controller.sid, Some(pixel_pos));
                participants_manager.set_cursor_mode(&controller.sid, controller.mode());
            } else {
                participants_manager.set_cursor_position(&controller.sid, None);
            }
        }
    }

    pub fn get_overlay_window(&self) -> Arc<OverlayWindow> {
        self.overlay_window.clone()
    }

    /// Triggers a click animation at the specified position for a given controller.
    ///
    /// This method handles the visual click animation feedback when a controller
    /// with pointer mode enabled performs a click action. It sends the necessary
    /// events to update the graphics and trigger the animation sequence.
    ///
    /// # Parameters
    ///
    /// * `position` - The position where the click animation should be displayed
    /// * `sid` - Session ID of the controller triggering the animation
    pub fn is_controllers_enabled(&self) -> bool {
        self.controllers_cursors_enabled
    }

    /// Hides cursors that have been inactive for longer than `CURSOR_HIDE_TIMEOUT`.
    ///
    /// This should be called during each redraw cycle, similar to how
    /// `update_auto_clear` works for drawing paths. Each cursor tracks
    /// when it was last shown, and cursors exceeding the timeout are
    /// automatically hidden.
    pub fn hide_inactive_cursors(&mut self) {
        let mut controllers_cursors = self.controllers_cursors.lock().unwrap();
        for controller in controllers_cursors.iter_mut() {
            controller.hide_if_expired();
        }

        if let Some(remote_control) = &self.remote_control {
            let mut sharer_cursor = remote_control.sharer_cursor.lock().unwrap();
            sharer_cursor.cursor_state.hide_if_expired();
        }
    }
}
